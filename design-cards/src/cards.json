{
    "colors": {
        "simple": {
            "background": "#003917",
            "line": "#aaffcc",
            "title": "#ffffff",
            "marble": "#003917"
        },
        "powerful": {
            "background": "#003917",
            "line": "#aaffcc",
            "title": "#ffffff",
            "marble": "#003917"
        },
        "abstract": {
            "background": "#162d50",
            "line": "#8ba7d9",
            "title": "#ffffff",
            "marble": "#162d50"
        },
        "concrete": {
            "background": "#162d50",
            "line": "#8ba7d9",
            "title": "#ffffff",
            "marble": "#162d50"
        },
        "pragmatic": {
            "background": "#501616",
            "line": "#f4d7d7",
            "title": "#ffffff",
            "marble": "#501616"
        },
        "idealistic": {
            "background": "#501616",
            "line": "#f4d7d7",
            "title": "#ffffff",
            "marble": "#501616"
        },
        "robust": {
            "background": "#ffe680",
            "line": "#784421",
            "title": "#000000",
            "marble": "#784421"
        },
        "technologic": {
            "background": "#ffe680",
            "line": "#784421",
            "title": "#000000",
            "marble": "#784421"
        },
        "question": {
            "background": "#ff9955",
            "line": "#784421",
            "title": "#000000",
            "marble": "#784421",
            "symbol": "?"
        },
        "action": {
            "background": "#ff9955",
            "line": "#784421",
            "title": "#000000",
            "marble": "#784421",
            "symbol": "!"
        }
    },
    "cards": [
        {
            "abbreviation": "KISS",
            "name": "Keep It Simple Stupid",
            "short": "Simple means readable, maintainable, and less error-prone. Overengineering is harmful.",
            "long": "Complex code typically contains more bugs and it has to be maintained (maybe even by other people). To others it may seem obscure which can lead to frustration and bad code quality. Striving for simplicity means to avoid having large methods/classes, many methods/classes/parameters, as well as inheritance, low-level optimization, complex algorithms, fancy (language) features, configurability, etc.",
            "links": "↓RoP, ↑CF, ↓NFR, ⇅MP",
            "set": "basic",
            "shield": "simple"
        },
        {
            "abbreviation": "YAGNI",
            "name": "You Ain't Gonna Need It",
            "short": "It's currently not necessary and you even have to maintain it!",
            "long": "Every piece of code you write, needs to be maintained. The more code you have, the more complexity there will be. Adding features and capabilities that are not used (yet), wastes time twice: When you write it and when you change, adjust, or even just read it. This becomes even more painful when you finally try to remove this dead code. So avoid things like runtime-configuration, internationalization, and features that are only there \"for the sake of completeness\". If it is really needed, it can be added later.",
            "links": "↓RoP, ↑CF, ↓NFR, ⇅MP",
            "set": "advanced",
            "shield": "simple"
        },
        {
            "abbreviation": "RoP",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "powerful"
        },
        {
            "abbreviation": "LC",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "abstract"
        },
        {
            "abbreviation": "DRY",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "concrete"
        },
        {
            "abbreviation": "CF",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "pragmatic"
        },
        {
            "abbreviation": "PoQ",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "idealistic"
        },
        {
            "abbreviation": "ML",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "robust"
        },
        {
            "abbreviation": "TP",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "technologic"
        },
        {
            "abbreviation": "Q1",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "question"
        },
        {
            "abbreviation": "A1",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "action"
        }
    ]
}
