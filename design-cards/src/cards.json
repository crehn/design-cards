{
    "colors": {
        "simple": {
            "background": "#003917",
            "line": "#aaffcc",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "powerful": {
            "background": "#003917",
            "line": "#aaffcc",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "abstract": {
            "background": "#162d50",
            "line": "#8ba7d9",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "concrete": {
            "background": "#162d50",
            "line": "#8ba7d9",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "pragmatic": {
            "background": "#900000",
            "line": "#f4d7d7",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "idealistic": {
            "background": "#900000",
            "line": "#f4d7d7",
            "title": "#ffffff",
            "qr": "#ffffff"
        },
        "robust": {
            "background": "#f0c873",
            "line": "#784421",
            "title": "#000000",
            "qr": "#784421"
        },
        "technologic": {
            "background": "#f0c873",
            "line": "#784421",
            "title": "#000000",
            "qr": "#784421"
        },
        "question": {
            "background": "#ff9955",
            "line": "#784421",
            "title": "#000000",
            "qr": "#784421",
            "symbol": "?"
        },
        "action": {
            "background": "#ff9955",
            "line": "#784421",
            "title": "#000000",
            "qr": "#784421",
            "symbol": "!"
        }
    },
    "cards": [
        {
            "abbreviation": "KISS",
            "name": "Keep It Simple Stupid",
            "short": "Simple means readable, maintainable, and less error-prone. Overengineering is harmful.",
            "long": "Complex code typically contains more bugs and it has to be maintained (maybe even by other people). To others it may seem obscure which can lead to frustration and bad code quality. Striving for simplicity means to avoid having large methods/classes, many methods/classes/parameters, as well as inheritance, low-level optimization, complex algorithms, fancy (lan-guage) features, configurability, etc.",
            "links": "↓RoP, ↑CF, ↓NFR, ⇅MP",
            "set": "basic",
            "shield": "simple"
        },
        {
            "abbreviation": "YAGNI",
            "name": "You Ain't Gonna Need It",
            "short": "It's currently not necessary and you even have to maintain it!",
            "long": "Code needs to be maintained. The more you have, the more complexity there will be. Adding features and capabilities that are not used (yet), wastes time twice: When you write the code and when you change or just read it. This becomes even more painful when you finally try to re-move this dead code. So avoid runtime-configu-ration, premature optimization, and features that are only there “for the sake of complete-ness”. If they are needed, add them later.",
            "links": "↓RoP, ↑CF, ↓NFR, ⇅MP",
            "set": "advanced",
            "shield": "simple"
        },
        {
            "abbreviation": "RoP",
            "name": "Rule of Power",
            "short": "Foresighted, generic solutions are reusable and future requirements will be addressed, too.",
            "long": "A powerful solution is better than a less potent one. Foresighted solutions reduce the necessity of refactoring and are more stable over time. Generic solutions often need less code and additionally offer extensibility by design. So better use abstractions, indirection, GoF patterns, polymorphism, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "powerful"
        },
        {
            "abbreviation": "LC",
            "name": "Low Coupling",
            "short": "Tight coupling creates ripple-effects and makes the code less maintainable.",
            "long": "If you decouple, you don't need to know internal details about other parts of the system. Furthermore it makes you independent from changes in those other parts and maybe even supports reuse. So better use additional layers, indirection, dependency injection, observers, messaging, etc.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "abstract"
        },
        {
            "abbreviation": "SRP",
            "name": "Single Responsibility Principle",
            "short": "One module should do one thing only.",
            "long": "If there is more than one reason to change a certain module (method/class/artifact/...), i.e. the module has more than one responsibility, then code becomes fragile. Changing one responsibility may result in involuntary changes to the other. Furthermore changing the module is more difficult and takes more time. And even when you don't change the module at all, understanding it is more complex. So better separate concerns into separate modules.",
            "links": "↑PSU, ↑IOSP, ⇅LC, ⇅KISS",
            "set": "advanced",
            "shield": "abstract"
        },
        {
            "abbreviation": "IOSP",
            "name": "Integration Operation Segregation Principle",
            "short": "A module should not contain API calls or business logic and integrate other modules.",
            "long": "Either a module is an operation, i.e. it contains business logic and/or API calls or it is an inte-gration, i.e. it calls other modules. That means operations should never call other modules and integrations should have no business logic and no API calls. Operations are easy to read, test, and reuse. Integrations are also simple as they just call other modules. This ensures that mod-ules are small and the system is well structured.",
            "links": "↑LC, ↑SRP, ⇅KISS, ⇅PSU",
            "set": "advanced",
            "shield": "abstract"
        },
        {
            "abbreviation": "DRY",
            "name": "Don't Repeat Yourself",
            "short": "Duplication makes changing the code cumbersome and leads to bugs.",
            "long": "Having a functionality more than once means to update or bugfix it at every occurrence which is more error-prone and more effort. Refactorings like method or class extraction may help as well as inheritance, polymorphism and some design patterns.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "concrete"
        },
        {
            "abbreviation": "IH/E",
            "name": "Information Hiding/Encapsulation",
            "short": "Only what is hidden, can be changed without risk.",
            "long": "There are 3 levels of IH/E: 1) Having a capsule means, that you have methods for accessing the data of the module. 2) Making the capsule opaque means that you can only access the data through the methods (i.e. all fields are private). 3) Making the capsule impenetrable means that you avoid returning references to mutable internal data structures. Either you make them immutable or you create copies in getter/setter methods.",
            "links": "↑MP, ↑LC, ↑FP, ⇅ KISS",
            "set": "advanced",
            "shield": "concrete"
        },
        {
            "abbreviation": "TdA/IE",
            "name": "Tell don't Ask/Information Expert",
            "short": "In OO design, objects should operate on their own data (and not on data of other objects).",
            "long": "Instead of asking a module for data, processing it, and putting it back afterwards, better just delegate. This reduces complexity in those classes which are already large. So avoid get-ters and setters in favor of methods containing domain logic. In other words: Logic should be implemented in that module that already has the necessary data, that is the information expert.",
            "links": "↑IH/E, ↓PSU, ⇅SRP, ⇅LC",
            "set": "advanced",
            "shield": "concrete"
        },
        {
            "abbreviation": "CF",
            "name": "Customer Focus",
            "short": "This is not what the customer pays us for!",
            "long": "If something is not requested, there has to be a very good reason to do it. Anything in addition costs additional time (also for removing or maintaining it). It creates additional risk of more bugs and makes you responsible for it. Continuously remember what was requested e.g. by looking into the requirements or asking the customer.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "pragmatic"
        },
        {
            "abbreviation": "ICC",
            "name": "In the Concrete Case",
            "short": "Your arguments are valid but in the concrete case the advantages won’t be important.",
            "long": "Many arguments hold true in general but when we look at the decision to be made, the effects they describe are sometimes negligible. Yes, low coupling is important, uniformity is helpful, and flexibility is desirable. But these aspects are sometimes crucial and sometimes irrele-vant. So better focus on arguments that are rel-evant in the concrete case instead of insisting on aspects just to satisfy idealistic pettiness.",
            "links": "↑CF, ↑YAGNI, ↓PoQ, ↓PSPG",
            "set": "advanced",
            "shield": "pragmatic"
        },
        {
            "abbreviation": "PoQ",
            "name": "Principle of Quality",
            "short": "Bad quality kills us in the long run!",
            "long": "It may be faster now but we need to be fast tomorrow, too. Bad quality frustrates maintainers, makes fixing bugs harder and leads to huge efforts for changes. This often starts by being careless once. Don't let a vicious circle begin. Use metrics, adhere to the architecture, have a high test coverage, apply code reviews and continuous refactoring. Don't be lazy.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "idealistic"
        },
        {
            "abbreviation": "PSPG",
            "name": "A Penny Saved Is a Penny Got",
            "short": "It might not be a big advantage, but it's not a big cost either.",
            "long": "Making little improvements a habit sums up to a big advantage. This is the reason behind the boy scout rule (“Leave the campground cleaner than you’ve found it”). You don’t have to clean the whole forest but if everyone leaves the campground just a little bit cleaner, we will have a clean forest in the end. So if it’s not a big deal, update libraries, improve documenta-tion, and refactor the classes you are currently touching anyway.",
            "links": "↑PoQ, ↑EaO, ↑FRD, ↓CF",
            "set": "advanced",
            "shield": "idealistic"
        },
        {
            "abbreviation": "ML",
            "name": "Murphy's Law",
            "short": "Avoid possibilities for something to go wrong or to get misused.",
            "long": "If there is a possibility for something to be used in the wrong way (like supplying parameters in the wrong order), it will eventually happen. So better avoid possible future bugs by using defensive programming, immutability, a common naming scheme, avoiding duplication and complexity.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "robust"
        },
        {
            "abbreviation": "FF",
            "name": "Fail fast",
            "short": "Program defensively or you'll have a hard time debugging.",
            "long": "If you don't check your inputs, cascading fail-ures can occur. This results in security prob-lems and error messages which are hard to de-cipher because they are not thrown at the posi-tion of the actual fault. This may even lead to situations where teams have to investigate fail-ures which are not theirs. So log and throw an error as soon as you realize a problem. The earlier the better, so throwing a compile-time error is preferable to run-time checks.",
            "links": "↑ML, ↑EUHM, ↓KISS, ↓NFR",
            "set": "advanced",
            "shield": "robust"
        },
        {
            "abbreviation": "TP",
            "name": "Technological Progress",
            "short": "Progress must not be ignored in a competitive environment.",
            "long": "New technology is not only motivating but also comes with benefits like more features, more performance, better maintainability, and fixed bugs. Furthermore old technology won't be supported for much longer and new people don't know the old stuff anymore. Continuously challenge existing solutions by evaluating alternatives.",
            "links": "↓KISS, ↑DRY, ↑FP, ↓RoE",
            "set": "basic",
            "shield": "technologic"
        },
        {
            "abbreviation": "qTRT",
            "name": "The Right Time",
            "short": "What will happen if we don't decide right now?",
            "long": "A design decision should be taken as late in the project as possible. But it's likewise harmful to take it too late. In order to find out if a decision really needs to be made now, think about what will happen, if the decision is deferred.",
            "links": "",
            "set": "basic",
            "shield": "question"
        },
        {
            "abbreviation": "aMed",
            "name": "Mediator",
            "short": "We cannot agree.  Let's get some help!",
            "long": "Sometimes a discussion gets stuck. In these cases it is often advisable to ask another colleague for an opinion or mediation. Usually a colleague who hasn't already participated in the discussion, adds a new, unbiased perspective.",
            "links": "",
            "set": "basic",
            "shield": "action"
        },
        {
            "abbreviation": "aPO",
            "name": "Product Owner Decides",
            "short": "This has a significant impact on the business so we have to talk with the product owner.",
            "long": "Some technical decisions influence the product itself. Often there is an impact on cost and time and sometimes there are even legal issues. Trade-offs include hosting an application in the cloud (flexibility and time vs. privacy and cost), adding a caching layer (performance vs. com-plexity and cost), make-or-buy (time vs. flexibi-lity and cost), etc. In those cases the decision is not merely a technical one. Involve the PO.",
            "links": "",
            "set": "advanced",
            "shield": "action"
        },
        {
            "abbreviation": "aCD",
            "name": "Client Decides",
            "short": "The client who calls the API knows best how the ideal API should look like.",
            "long": "APIs need to be intuitive to those who use it and sometimes it's hard to predict if that's the case. Some decisions have an impact on how a module can be used. Some use cases may get simpler and others may get harder and less intuitive. Better stop assuming you know what's best for the clients. Just ask and involve them in your decision.",
            "links": "",
            "set": "advanced",
            "shield": "action"
        }
    ]
}

